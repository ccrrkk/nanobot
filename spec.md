这是我阅读nanobot文档后总结的几个重要点：

## 完整流程


nanobot 的核心是一个基于循环的智能体架构，主要流程如下：

1. **消息接收**
  - 智能体通过消息总线（MessageBus）异步接收来自各渠道（如 IM、CLI、子代理等）的消息。

2. **会话与上下文管理**
  - 根据消息的 channel 和 chat_id 获取或创建对应的会话（Session），维护消息历史。
  - 检查是否为特殊命令（如 /new、/help），如是则优先处理。
  - 若消息数超过窗口限制，自动触发记忆归档，将旧消息摘要写入长期记忆。

3. **上下文构建**
  - 由 ContextBuilder 组装 System Prompt、长期记忆（MEMORY.md）、近期消息历史、媒体信息等，生成 LLM 输入上下文。

4. **主循环（Agent Loop）**
  - 采用“思考-行动-观察”模式（Think-Act-Observe）：
    1. 调用 LLM 进行推理，生成回复或工具调用计划。
    2. 若 LLM 产生工具调用（如文件、Shell、Web、消息、子代理等），则依次执行对应工具，将结果作为 observation 反馈给 LLM。
    3. 工具执行结果会追加到上下文，LLM 可多轮反思与决策，直至任务完成或达到最大迭代次数。
    4. 若无工具调用，直接输出最终回复。

5. **消息写入与响应**
  - 用户消息、助手回复（含工具调用信息）均通过 Session.add_message 写入会话历史。
  - 会话历史自动持久化到本地 session 文件。
  - 最终回复通过消息总线发送到对应渠道。

6. **记忆归档与长期知识更新**
  - 会话历史超限或用户主动触发时，自动归档旧消息。
  - 归档流程由 LLM 生成对话摘要和长期记忆增量，分别写入 HISTORY.md 和 MEMORY.md。

7. **子代理与系统消息**
  - 支持通过 SpawnTool 派生子代理，子代理可独立处理子任务，结果通过 system channel 汇总回主会话。

整个流程实现了消息驱动、上下文感知、工具增强、长期记忆与多会话协同，适用于复杂任务的智能体自动化。



## skills管理

nanobot 的技能（Skills）是赋予智能体执行特定任务能力的模块化组件。其管理机制如下：

### 1. 技能存储与结构
- **存储位置**：分为内置技能（`nanobot/skills/`）和工作区技能（`workspace/skills/`）。工作区技能具有更高优先级，可覆盖同名的内置技能。
- **文件格式**：每个技能是一个以技能名命名的目录，核心内容定义在其中的 `SKILL.md` 文件中。
- **元数据**：技能文件的开头使用 YAML Frontmatter 定义属性，如 `description`、`always`（是否总是加载）、以及 `requires`（所依赖的命令行工具或环境变量）。

### 2. 加载机制：渐进式加载（Progressive Loading）
为了避免庞大的技能文档撑爆上下文窗口，nanobot 采用了渐进式加载：
- **Summary 型加载**：系统会自动扫描所有可用技能，并生成一个轻量级的 XML 摘要注入到 System Prompt 中。摘要包含技能名、描述、文件路径以及可用状态。
- **Always 型加载**：对于配置了 `always: true` 的核心技能，系统会将其完整正文直接注入上下文。
- **按需读取**：如果智能体根据摘要判断某项技能适合当前任务，它可以自主调用 `read_file` 工具读取 `SKILL.md` 的内容来学习具体操作步骤。

### 3. 环境与依赖检查
- 每个技能可以声明其运行所需的二进制工具（如 `ffmpeg`、`git`）或环境变量（如 `OPENAI_API_KEY`）。
- `SkillsLoader` 会在加载前检查当前环境。如果依赖不满足，该技能在摘要中会被标记为 `available="false"`，并告知缺失的项，防止智能体误用。

### 4. 技能的动态发现
- 智能体启动或构建上下文时，`SkillsLoader` 会动态扫描目录。用户只需将新的技能目录放入 `workspace/skills/`，无需更改任何 Python 代码或配置文件即可完成能力的扩展。


## 记忆机制


nanobot 采用了分层的记忆机制，结合短期对话历史与长期知识归档，具体如下：

### 1. 消息写入与短期记忆
- 每个会话（Session）对象维护一份消息列表，所有用户与助手的消息（包括内容、角色、时间戳、工具调用等）通过 `Session.add_message` 方法追加到该列表。
- 消息结构为字典，包含 role、content、timestamp 及可选的 tools_used 等字段。
- 会话历史通过 `SessionManager` 管理，支持多会话隔离，消息会同步写入本地 session 文件（JSONL 格式，位于 `~/.nanobot/sessions/`）。
- 构建 LLM 上下文时，系统会自动选取最近 N 条消息（如 50 条，由 memory_window 参数控制）作为短期记忆，参与推理。

### 2. 长期记忆存储
- 长期记忆以文本形式存储在 `workspace/memory/MEMORY.md`，内容为用户事实、偏好、项目信息等。
- 另一份 `workspace/memory/HISTORY.md` 用于存储历史事件摘要，便于全文检索。
- 这两份文件由 `MemoryStore` 管理，支持读写和追加操作。

### 3. 记忆归档与合并机制
- 当会话消息数超过窗口限制（memory_window）时，系统会自动触发记忆归档（consolidation）。
- 归档流程：
  1. 选取需要归档的旧消息（通常保留最新一半，旧的一半归档）。
  2. 将这些消息整理为带时间戳的对话文本，连同当前长期记忆内容，拼接成归档提示（prompt）。
  3. 调用 LLM 生成 JSON 格式的摘要，包含：
     - `history_entry`：对本轮对话的事件/决策/主题进行2-5句摘要，带时间戳，便于后续检索。
     - `memory_update`：对长期记忆内容进行增量更新，补充新事实、偏好、项目进展等。
  4. 摘要写入 HISTORY.md，长期记忆写入 MEMORY.md（如有更新）。
  5. 归档后，session 只保留最新一部分消息，并更新 last_consolidated 游标。
- 归档既可自动触发，也可通过 /new 命令手动触发（此时所有历史消息立即归档，开启新会话）。

### 4. 记忆检索与上下文注入
- 构建 LLM 上下文时，会自动注入 MEMORY.md 的内容，辅助推理。
- HISTORY.md 可通过 grep 等工具全文检索，快速定位历史事件。

### 5. 机制优势
- 这种机制兼顾了上下文窗口限制与长期知识积累，确保代理既能记住重要事实，又能高效处理新对话。
- 归档摘要由 LLM 生成，具备较强的信息提炼能力，能动态更新长期知识。

## 子代理（Subagent）

nanobot 支持通过子代理机制实现后台长时间运行的任务，而不阻塞主会话。

### 1. 核心定位
- **异步执行**：子代理运行在独立的协程中（`asyncio.Task`），主代理在派生（Spawn）后可立即响应用户。
- **能力限制**：子代理拥有文件操作、Shell 执行、网页搜索等权限，但被剥夺了“发送消息”和“再次派生子代理”的能力，以防逻辑闭环或无限递归。

### 2. 生命周期管理
- **派生（Spawn）**：通过 `SpawnTool` 触发。`SubagentManager` 负责分配唯一的 `task_id` 并管理其生命周期。
- **环境隔离**：子代理不共享主会话的消息历史，旨在从零开始执行专项任务。
- **最大迭代**：内部限制最大迭代次数（如 15 次），防止 LLM 在后台任务中因死循环耗尽资源。

### 3. 通讯与反馈机制
- **系统总线注入**：子代理完成后，不会直接向用户发送消息，而是将结果封装为 `channel="system"` 的消息发回 `MessageBus`。
- **自然语言汇总**：主代理接收到该系统消息后，会感知到子代理任务已结束，并根据结果内容生成一段自然语言汇总告知用户。

### 4. 应用场景
- 复杂问题的深度搜索（WebSearch）。
- 需要多步骤编译、测试或运行的代码重构任务（Shell + Filesystem）。
- 大规模文件的分析处理。

